"""
Syllabus content definitions for different roles and difficulty levels.

This module contains the comprehensive topic banks for each role, organized by
difficulty level and category (tech, tech_allied).
"""
from __future__ import annotations

from typing import Dict, List

# Main syllabus structure: role -> difficulty -> category -> topics
SYLLABUS: Dict[str, Dict[str, Dict[str, List[str]]]] = {
    "React Developer": {
        "easy": {
            "tech": [
                "React vs Frameworks – React focuses on the view layer, unlike frameworks that provide opinions on routing, state, and architecture.",
                "Component-Based Architecture – React encourages UIs built from small, reusable, and independent pieces called components.",
                "Functional Components – Modern React favors function components over classes for simplicity and maintainability.",
                "Class Components – Older codebases may still contain class components using lifecycle methods and this state.",
                "JSX Overview – JSX allows HTML-like markup directly in JavaScript, compiled into standard JS calls by Babel.",
                "Props – Properties passed from parent to child components; immutable within the child.",
                "State – Component-local data that triggers re-renders when updated.",
                "State vs Props – Props are external and immutable; state is internal and mutable.",
                "Conditional Rendering – Dynamically rendering components or elements based on state or props.",
                "Rendering Lists – Mapping arrays to components with a unique key prop to optimize updates.",
                "Component Lifecycle – Functional components use hooks like useEffect to manage side effects.",
                "Event Handling – React standardizes browser events and synthetic event objects.",
                "Handling User Input – Controlled components store input state in React rather than the DOM.",
                "Form Validation – Basic validation using component state and conditional rendering.",
                "JSX Expressions – Embedding variables, operators, and function calls directly in JSX.",
                "JSX Conditional Operators – Using ternary operators or logical AND for inline conditional rendering.",
                "React Fragments – Grouping multiple elements without adding extra DOM nodes.",
                "Inline Styling in JSX – Applying JavaScript objects as style attributes.",
                "Component Composition – Combining multiple smaller components to form complex UI structures.",
                "React Keys – Providing stable identifiers to lists for proper diffing and reconciliation.",
                "React Children Prop – Accessing nested components passed into a parent component.",
                "Default Props – Defining fallback values for props if none are provided.",
                "Prop Types – Optional runtime validation of props to catch incorrect types.",
                "Basic Hooks Overview – Hooks let functional components access state and lifecycle features.",
                "useState Hook – Declaring and updating component-local state variables.",
                "useEffect Hook – Performing side effects such as fetching data or subscribing to events.",
                "useRef Hook – Accessing DOM elements or persisting mutable values without causing re-renders.",
                "useContext Hook – Consuming values from a Context provider without prop drilling.",
                "useReducer Hook – Managing complex state with reducer functions.",
                "useMemo Hook – Memoizing values to prevent unnecessary recalculations.",
                "useCallback Hook – Memoizing functions to prevent unnecessary re-creations.",
                "Creating Custom Hooks – Extracting reusable logic from components into custom hooks.",
                "React Context API – Providing shared state to multiple components without manually passing props.",
                "Passing Data Down the Tree – Using props to move data from parent to child components.",
                "Prop Drilling Problem – When multiple levels of components must pass data down explicitly.",
                "React Strict Mode – Highlighting potential issues and unsafe lifecycles during development.",
                "JSX Comments – Adding comments inside JSX without affecting rendered output.",
                "Fragment Shorthand – Using <>...</> instead of <React.Fragment>.",
                "Conditional Class Names – Dynamically applying CSS classes based on state or props.",
                "Event Propagation in React – Understanding synthetic event bubbling and capture phases.",
                "Handling Multiple Inputs – Managing multiple controlled form fields efficiently.",
                "Reusable Component Patterns – Structuring components to maximize reuse and flexibility.",
                "State Lifting – Moving shared state to a common parent to synchronize child components.",
                "Component Isolation – Ensuring components are independent and easily testable.",
                "Debugging JSX – Using browser DevTools and React DevTools to inspect component hierarchy.",
                "JSX Spread Attributes – Passing props dynamically using the spread operator.",
                "JSX Children Mapping – Iterating over nested children with React.Children.map.",
                "Basic CSS in React – Applying classes or inline styles to JSX elements.",
                "React DevTools Overview – Inspecting components, state, and props in development.",
            ],
            "tech_allied": [
                "ES6+ features (let/const, arrow functions, spread/rest)",
                "NPM/Yarn basics and scripts",
                "CSS approaches (CSS Modules, styled-components, Tailwind basics)",
                "Bundling with Vite/Webpack basics",
                "Data fetching with fetch/axios",
                "Basic testing with Jest/RTL",
                "Simple accessibility (labels, alt text, focus order)",
                "Basic TypeScript with React (FC, Props)",
                "Linting and formatting (ESLint/Prettier)",
                "Environment variables (.env) for frontend",
                "Devtools basics (React DevTools)",
                "HTTP status codes and simple error handling",
                "Package management (lockfiles, semver)",
                "Basic Git workflow (branch, commit, PR)",
            ],
        },
        "medium": {
            "tech": [
                "React Router Overview – Client-side routing for single-page applications (SPAs).",
                "Route Components – Mapping URLs to React components using Route.",
                "Dynamic Routing – Generating routes based on data or parameters.",
                "Nested Routes – Embedding child routes inside parent route layouts.",
                "Navigation Links – Using Link or NavLink to navigate without page reloads.",
                "Programmatic Navigation – Navigating via useNavigate or history API in React Router.",
                "React Router Guards – Protecting routes for authenticated users.",
                "TanStack Router Overview – Alternative SPA routing library with advanced features.",
                "CSS Modules – Local-scoped styles to prevent collisions in component-based architecture.",
                "Utility-First CSS – Using frameworks like Tailwind CSS for atomic styling.",
                "Styled Components – CSS-in-JS for dynamic and component-scoped styling.",
                "Component Libraries Overview – Prebuilt sets of UI components like Material UI or Chakra UI.",
                "Theming in React – Managing light/dark mode and consistent design tokens across components.",
                "Responsive Design in React – Using CSS, media queries, or libraries to adapt layouts.",
                "React Hooks for Styling – Using useState and useEffect to dynamically change styles.",
                "Global State Management – Handling application-wide state for multi-component coordination.",
                "Context API for Global State – Lightweight solution for low-frequency shared data.",
                "Zustand Overview – Minimalist state management using hooks.",
                "Jotai Overview – Atomic state management for independent state slices.",
                "MobX Overview – Observable state with reactive updates for scalable applications.",
                "Prop Drilling Alternatives – Using Context or state management libraries to reduce boilerplate.",
                "REST API Integration – Fetching data from endpoints using React Query, SWR, or Axios.",
                "Caching Data – Using libraries like React Query to cache server responses.",
                "Automatic Refetching – Keeping client state synchronized with server data.",
                "GraphQL API Integration – Using Apollo Client or Relay for efficient queries.",
                "Query vs Mutation in GraphQL – Queries fetch data; mutations modify data on the server.",
                "Optimistic UI Updates – Updating the interface before server confirmation for faster UX.",
                "Form State Management – Using controlled/uncontrolled components for input handling.",
                "React Hook Form – Simplifying form state, validation, and submission.",
                "Formik Overview – Another library for declarative form management.",
                "Form Validation Strategies – Schema-based validation with Zod or Yup.",
                "TypeScript in React – Adding static types for improved developer experience and safety.",
                "Typing Props in TypeScript – Explicitly defining expected prop types for components.",
                "Typing State in TypeScript – Ensuring state variables adhere to expected shapes.",
                "Zod for Runtime Validation – Validating form inputs or API responses with schemas.",
                "React Query Prefetching – Loading data ahead of user interactions.",
                "Pagination and Infinite Scroll – Efficiently displaying large datasets.",
                "Suspense for Data Fetching – Declarative waiting for asynchronous operations.",
                "Error Handling in Data Fetching – Displaying fallback UI for API errors.",
                "Code Splitting in React – Splitting code to reduce bundle size and improve load times.",
                "Lazy Loading Components – Dynamically importing components only when needed.",
                "Memoization in React – Using useMemo and useCallback to prevent unnecessary re-renders.",
                "React Profiler Overview – Measuring performance of components and hooks.",
                "React DevTools Performance Tab – Profiling and optimizing UI performance.",
                "Animations in React – Using CSS, Framer Motion, or react-spring for dynamic effects.",
                "Portals in React – Rendering components outside the parent DOM hierarchy for modals or tooltips.",
                "Error Boundaries – Catching and handling runtime errors in React components.",
                "Accessibility in React – Using semantic markup, ARIA roles, and keyboard navigation.",
                "Internationalization (i18n) – Adapting UI for multiple languages and locales.",
                "Localization (l10n) – Formatting translations, numbers, and dates for specific regions.",
            ],
            "tech_allied": [
                "Routing (React Router, nested routes)",
                "State mgmt (Redux/RTK, Zustand, Jotai)",
                "Testing (Jest, React Testing Library) including mocks",
                "Accessibility (ARIA, keyboard navigation, focus management)",
                "CSS performance and theming",
                "Code splitting and lazy loading",
                "TypeScript patterns (Discriminated unions, generics in props)",
                "API error states and retries",
                "Form libs (React Hook Form, Formik)",
                "Design tokens and theming in UI kits",
                "Storybook and component documentation",
                "i18n basics (react-intl, i18next)",
                "Analytics hooks and event tracking",
            ],
        },
        "hard": {
            "tech": [
                "Next.js Overview – Meta-framework for React with SSR, SSG, routing, and API routes.",
                "Server-Side Rendering (SSR) – Rendering components on the server for performance and SEO.",
                "Static Site Generation (SSG) – Pre-rendering pages at build time for fast delivery.",
                "Incremental Static Regeneration (ISR) – Updating static pages incrementally without full rebuilds.",
                "Dynamic Routing in Next.js – File-based routing with dynamic URL segments.",
                "API Routes in Next.js – Building serverless endpoints alongside frontend pages.",
                "Astro Overview – Framework emphasizing minimal JavaScript shipping for optimized performance.",
                "Suspense for Code-Splitting – Declaratively waiting for component or data loading.",
                "Concurrent Rendering in React – Optimizing render performance with React 18 features.",
                "React 18 Automatic Batching – Grouping multiple state updates to reduce re-renders.",
                "Server Components – Rendering React components on the server to reduce client bundle size.",
                "Streaming SSR – Sending HTML progressively to improve Time to First Byte.",
                "React Portals for Advanced UI – Modals, tooltips, and dropdowns rendered outside main DOM hierarchy.",
                "Error Boundaries for Production – Gracefully recovering from component-level errors.",
                "React Lazy and Suspense for Images – Loading media progressively to reduce initial load.",
                "Framer Motion Animations – Creating fluid, declarative motion in React UIs.",
                "React Spring Animations – Physics-based animation library for interactive components.",
                "React Native Overview – Building truly native mobile apps with React syntax.",
                "Cross-Platform UI Patterns – Sharing React code between web and mobile platforms.",
                "Performance Optimization Strategies – Memoization, lazy loading, and code splitting.",
                "Critical Rendering Path Optimization – Reducing render-blocking scripts and CSS.",
                "Web Vitals Monitoring – Tracking LCP, FID, and CLS in production apps.",
                "Bundle Analysis – Analyzing and minimizing JavaScript bundle sizes.",
                "Tree Shaking – Removing unused code during the build process.",
                "Progressive Web App Features – Offline support, caching, and push notifications.",
                "Service Worker Implementation – Background caching and offline handling.",
                "IndexedDB for Offline Storage – Storing structured data client-side for offline use.",
                "WebSocket Integration in React – Real-time data updates in SPAs.",
                "GraphQL Client Optimization – Efficient caching, batching, and pagination.",
                "Optimistic Updates in React – Immediate UI updates while awaiting server confirmation.",
                "Error Handling Patterns – Global error handling strategies with hooks or higher-order components.",
                "Authentication Strategies – OAuth, JWT, and cookie-based authentication.",
                "Authorization Flows in React – Restricting component access based on user roles.",
                "Security Best Practices – Preventing XSS, CSRF, and injection attacks in client code.",
                "Environment Variables in React – Managing secrets and configuration safely in builds.",
                "Continuous Integration for React – Automating build, test, and deployment pipelines.",
                "Continuous Deployment for React – Automatic production deployment with CI/CD workflows.",
                "Monitoring and Logging in Production – Capturing errors, performance metrics, and user behavior.",
                "Advanced State Management Patterns – Combining Context, Redux, or Zustand in large apps.",
                "Micro-Frontend Architecture – Splitting applications into independently deployable modules.",
                "Module Federation – Sharing components between micro-frontends or projects.",
                "Code Splitting and Dynamic Imports – Loading components or libraries only when needed.",
                "Optimized Image Handling – Responsive images, lazy loading, and modern formats like WebP.",
                "Advanced Forms Handling – Conditional fields, dynamic validation, and nested forms.",
                "Schema-Based Validation with Zod – Runtime validation of API responses and forms.",
                "Testing Unit Components – Using Jest or Vitest for isolated tests.",
                "Component Testing with React Testing Library – Testing components from the user perspective.",
                "End-to-End Testing with Cypress or Playwright – Automated browser testing of full user flows.",
                "Profiling React Apps – Using DevTools and performance APIs to detect bottlenecks.",
                "Front-End Architecture Design – Building scalable, maintainable, and performant React applications.",
            ],
            "tech_allied": [
                "Microfrontends architectures",
                "Advanced code splitting and prefetching",
                "Security (XSS, CSP in SPAs, sandboxing)",
                "Internationalization at scale (pluralization, RTL)",
                "Design systems governance and tokens",
                "Bundle budgets and performance regressions",
                "SSR/SSG/ISR strategies (Next.js deep dive)",
                "Edge rendering and CDN caching",
                "Web vitals instrumentation and SLOs",
                "A/B testing and feature flags integration",
                "Error boundaries strategy at app scale",
                "Release strategies (canary, dark launches)",
            ],
        },
    },
    "UI Developer": {
        "easy": {
            "tech": [
                "How the Internet works: Client-server model, IP addresses, and data flow",
                "HTTP protocol basics: GET, POST, PUT, DELETE methods",
                "HTTP status codes: 200, 404, 500 and their meanings",
                "HTTP headers: Metadata for requests and responses (caching, content type, authentication)",
                "DNS basics: Translating domain names to IP addresses",
                "Hosting and domains: Human-friendly addresses and server storage",
                "HTML overview: Structuring web content with elements and tags",
                "Common HTML tags: Headings, paragraphs, links, images, lists, tables",
                "Semantic HTML: <article>, <section>, <header>, <footer> for accessibility and SEO",
                "HTML forms: Inputs, radio buttons, checkboxes, selects for user input",
                "HTML validation: required, pattern, and type attributes",
                "ARIA attributes: Enhancing accessibility for assistive technologies",
                "CSS fundamentals: Selectors, properties, and values for visual presentation",
                "Box model: Content, padding, border, margin for layout control",
                "Cascade and specificity: How CSS rules are applied",
                "Inheritance in CSS: How properties pass from parent to child",
                "Flexbox basics: One-dimensional layout for rows and columns",
                "CSS Grid basics: Two-dimensional layout with rows, columns, and areas",
                "Responsive design concepts: Media queries and fluid layouts",
                "CSS preprocessors: Sass for variables, mixins, and nesting",
                "BEM methodology: Block-Element-Modifier naming for scalable CSS",
                "Version control with Git: Tracking changes and collaboration",
                "Git workflow: Repositories, commits, branches, merges, conflict resolution",
                "Git hosting platforms: GitHub, GitLab, Bitbucket for cloud repositories",
                "Node Package Manager (npm): Managing JavaScript packages and dependencies",
                "Alternative package managers: pnpm and yarn for speed and efficiency",
                "Linters: ESLint for syntax errors and code standards",
                "Formatters: Prettier for consistent code formatting",
                "Module bundlers: Webpack, Vite, esbuild for optimizing JavaScript modules",
                "Browser developer tools: Inspecting and debugging HTML, CSS, and JavaScript",
                "DOM basics: Document Object Model as a tree of nodes",
                "Selecting DOM elements: getElementById, querySelector, querySelectorAll",
                "Manipulating the DOM: Modifying text, attributes, and styles with JavaScript",
                "Adding event listeners: Handling clicks, input changes, and user interactions",
                "Event bubbling and capturing: How events propagate in the DOM",
                "Form handling in JavaScript: Validating input and processing submissions",
                "LocalStorage: Persistent client-side key-value storage",
                "SessionStorage: Temporary storage for the current session",
                "Cookies: Storing small data with optional expiration for sessions",
                "JSON basics: Standard data exchange format between client and server",
                "Parsing JSON: JSON.parse() to convert strings to objects",
                "Stringifying JSON: JSON.stringify() to convert objects to strings",
                "Console API: console.log, console.warn, console.error for debugging",
                "JavaScript variables in the browser: var, let, const and scope",
                "Primitive vs reference types: Assignment, comparison, and function behavior",
                "Template literals: Backtick strings with embedded expressions",
                "Basic CSS selectors: Type, class, ID, and attribute selectors",
                "CSS combinators: Descendant, child, and sibling relationships in selectors",
            ],
            "tech_allied": [
                "Accessibility basics (landmarks, roles, labels)",
                "Color contrast & typography",
                "Asset optimization (images, fonts)",
                "Browser DevTools essentials",
                "Core Web Vitals (LCP/FID/CLS) basics",
                "Image formats (PNG/JPEG/WebP/AVIF/SVG)",
                "Icon systems and sprite sheets",
                "Design handoff (Figma/Zeplin) basics",
                "Simple build setups (Vite) for static sites",
                "Reset vs normalize CSS",
            ],
        },
        "medium": {
            "tech": [
                "Introduction to Frontend Frameworks – Frameworks like React, Angular, Vue, and Svelte simplify UI management in complex applications.",
                "React Component Architecture – Components encapsulate markup, styles, and behavior in reusable units.",
                "JSX Syntax – JSX allows HTML-like markup inside JavaScript functions or classes.",
                "Component Props – Props pass external data into a component for dynamic rendering.",
                "Component State – State represents internal data that changes over time and triggers UI updates.",
                "React Hooks Basics – useState and useEffect manage state and side effects in functional components.",
                "Conditional Rendering in React – Components display different UI depending on state or props.",
                "Rendering Lists in React – Efficiently render collections using keys for reconciliation.",
                "Handling User Events in React – React standardizes event handling across browsers.",
                "Lifecycle Methods in Class Components – Mounting, updating, and unmounting phases control side effects.",
                "Functional vs Class Components – Understanding their differences affects state and lifecycle management.",
                "Component Composition – Combining smaller components to build complex UI structures.",
                "Context API – Sharing global state without prop drilling across deeply nested components.",
                "React Router Basics – Implementing navigation between pages in single-page applications.",
                "Form Handling in React – Managing controlled and uncontrolled components for user input.",
                "Fetch API in React – Performing asynchronous HTTP requests within components.",
                "Async/Await in Frontend – Writing asynchronous code in a readable, synchronous style.",
                "Promises in UI Development – Handling deferred results of asynchronous operations.",
                "Error Handling in Async Operations – Graceful handling of network or computation errors.",
                "Web Security Overview – Frontend developers prevent vulnerabilities like XSS, CSRF, and data leaks.",
                "Cross-Origin Resource Sharing (CORS) – A browser security feature restricting cross-domain requests.",
                "HTTPS and TLS – Securing data transmission with encryption and authentication.",
                "Content Security Policy (CSP) – Preventing script injection and other attacks with security headers.",
                "OWASP Frontend Risks – Awareness of common vulnerabilities ensures safer applications.",
                "Unit Testing React Components – Testing individual components with frameworks like Jest.",
                "Integration Testing – Ensuring that multiple components work together correctly.",
                "End-to-End Testing – Simulating real user interactions using Cypress or Playwright.",
                "Core Web Vitals – Metrics such as LCP, FID, and CLS quantify user experience.",
                "Performance Profiling – Using DevTools to identify and resolve bottlenecks.",
                "RAIL Performance Model – Structuring frontend responsiveness around Response, Animation, Idle, Load.",
                "PRPL Optimization Pattern – Push, Render, Pre-cache, and Lazy-load strategy for faster applications.",
                "Lazy Loading Components – Loading only what’s necessary to reduce initial page weight.",
                "Code Splitting – Dividing applications into smaller bundles for better performance.",
                "Tree Shaking – Removing unused code during the build process.",
                "TypeScript Basics for Frontend – Introducing static types to manage large-scale applications.",
                "Type Annotations – Explicitly defining variable and function types for better clarity.",
                "Type Inference – Allowing TypeScript to automatically determine types.",
                "Interfaces and Types – Describing shapes of objects, arrays, and functions in TypeScript.",
                "React with TypeScript – Combining type safety with component-driven development.",
                "Strict Mode in React – Highlighting potential problems and unsafe lifecycles during development.",
                "Accessibility in React – Using semantic tags, ARIA, and keyboard navigation for inclusive UI.",
                "CSS Modules – Scoped CSS to avoid naming collisions in component-based architectures.",
                "Styled Components – Writing component-specific CSS within JavaScript files.",
                "Preprocessors in React Projects – Sass or Less to enhance maintainability of component styles.",
                "CSS-in-JS Patterns – Dynamic styling with JavaScript for modern UI libraries.",
                "Browser Compatibility – Ensuring consistent behavior across different browsers and versions.",
                "Polyfills – Filling missing functionality in older browsers for modern JavaScript features.",
                "Feature Detection – Checking for API support before using new features.",
                "Responsive Images – Serving appropriate image sizes to optimize performance.",
                "SVG Graphics in UI – Scalable, resolution-independent vector graphics for modern interfaces.",
            ],
            "tech_allied": [
                "WCAG 2.x and a11y testing",
                "Design tokens and theming",
                "Build tooling (Vite/Webpack/Rollup)",
                "Unit/E2E testing (RTL, Playwright)",
                "Performance audits (Lighthouse) and budgets",
                "Fonts: variable fonts, FOIT/FOUT mitigation",
                "Internationalization (RTL, locale data)",
                "Content security basics for UI",
                "Design QA and visual regression testing",
                "UX heuristics and usability basics",
            ],
        },
        "hard": {
            "tech": [
                "Single Page Applications (SPA) – SPAs dynamically update content without full-page reloads for a smooth UX.",
                "Virtual DOM – React’s efficient representation of UI to minimize real DOM manipulations.",
                "Reconciliation in React – Determining the minimal set of changes needed to update the DOM.",
                "State Management Patterns – Using Redux, Zustand, or Context API to manage complex state.",
                "Immutable Data in UI – Preventing unintended side effects by avoiding direct mutations.",
                "Flux Architecture – Unidirectional data flow for predictable UI state changes.",
                "Observer Pattern in UI – Components reacting to state changes or events automatically.",
                "Debouncing Functions – Limiting function calls to improve performance during frequent events.",
                "Throttling Functions – Ensuring functions execute at most once per defined interval.",
                "Memoization Techniques – Caching expensive computations to optimize rendering.",
                "Use of Web Workers – Offloading heavy computations to separate threads in the browser.",
                "Service Workers – Enabling offline functionality and caching for progressive web apps.",
                "Progressive Web Apps (PWA) – Applications that combine web reach with native app capabilities.",
                "Push Notifications in PWAs – Engaging users via background notifications.",
                "IndexedDB – Storing structured client-side data for offline applications.",
                "Dynamic Imports in JavaScript – Loading modules on demand for performance improvements.",
                "Advanced React Hooks – useReducer, useCallback, and useMemo for complex logic optimization.",
                "React Portals – Rendering children into DOM nodes outside the parent hierarchy.",
                "Error Boundaries – Catching and handling rendering errors in React components.",
                "Testing Asynchronous UI – Simulating API calls and asynchronous updates in tests.",
                "Continuous Integration (CI) for Frontend – Automating builds, tests, and deployment.",
                "Code Splitting with React Router – Loading routes dynamically to reduce initial load.",
                "Server-Side Rendering (SSR) – Rendering React components on the server for performance and SEO.",
                "Static Site Generation (SSG) – Pre-rendering pages at build time for faster delivery.",
                "Hydration in React – Attaching event listeners to server-rendered markup.",
                "Front-End Security Best Practices – Avoiding XSS, CSRF, and other client-side attacks.",
                "Content Security Policy Enforcement – Implementing CSP to mitigate script injection.",
                "OAuth and JWT Basics – Token-based authentication for secure frontend access.",
                "WebSockets for Real-Time UI – Bidirectional communication for live updates.",
                "GraphQL for Data Fetching – Flexible query language to retrieve only necessary data.",
                "Optimistic UI Updates – Updating the interface before server confirmation for responsiveness.",
                "Code Profiling and Performance Monitoring – Identifying bottlenecks using DevTools and Lighthouse.",
                "Memory Management in the Browser – Understanding leaks and efficient resource usage.",
                "Advanced CSS Grid Techniques – Nested grids, auto-placement, and dynamic layouts.",
                "Complex Flexbox Layouts – Combining alignment, wrapping, and distribution strategies.",
                "Animations with CSS and JS – Smooth transitions using keyframes, transitions, and libraries like GSAP.",
                "Canvas API for 2D Graphics – Drawing graphics programmatically in the browser.",
                "WebGL for 3D Rendering – GPU-accelerated 3D graphics within web applications.",
                "Accessibility Audits – Evaluating applications for compliance with WCAG standards.",
                "Internationalization (i18n) – Adapting UI for multiple languages and locales.",
                "Localization (l10n) – Implementing translations, formatting, and currency adjustments.",
                "Reactive Programming Patterns – Handling asynchronous data streams efficiently.",
                "Front-End Architectural Patterns – Modular, scalable, and maintainable application structures.",
                "Micro-Frontend Architecture – Splitting frontend applications into independently deployable modules.",
                "Package Optimization and Tree Shaking – Removing unused code to reduce bundle size.",
                "Front-End Monitoring and Logging – Tracking errors and performance metrics in production.",
                "Browser Rendering Pipeline – Understanding parsing, layout, paint, and compositing.",
                "Critical Rendering Path Optimization – Reducing render-blocking resources for faster paint.",
                "Prefetching and Preloading Resources – Loading assets ahead of time to improve responsiveness.",
                "Front-End Specialization Paths – Choosing between advanced React, backend integration, or performance-focused UI development.",
            ],
            "tech_allied": [
                "Advanced a11y (focus traps, screen readers)",
                "Internationalization at scale",
                "Design systems governance & documentation",
                "Performance budgets and regressions",
                "Security (clickjacking, CSP)",
                "Cross-browser/platform QA at scale",
                "Experimentation frameworks",
                "Privacy and consent management (CMP)",
                "Monitoring front-end errors (Sentry)",
            ],
        },
    },
    "JavaScript Developer": {
        "easy": {
            "tech": [
                "History and Standardization of JavaScript – An overview of how JavaScript originated, its evolution, and how the ECMAScript specification governs its features.",
                "Major Changes Introduced in ES6 and Later Versions – A look at ES6 as a milestone and how subsequent versions expanded the language.",
                "Executing JavaScript in the Browser Console – Exploring the built-in tools in browsers for running and testing code interactively.",
                "Running JavaScript in Node.js – Understanding how Node.js allows JavaScript to run outside the browser environment.",
                "Variable Declarations with var – Explanation of function-scoped variables and their limitations.",
                "Block-Scoped Variables with let – Use of let for variables tied to block-level scope.",
                "Constants with const – The role of immutable variable bindings in safer programming.",
                "Variable Naming Conventions in JavaScript – Common rules and best practices for clear, consistent variable names.",
                "Scopes in JavaScript – Differentiating between global, function, and block-level scope.",
                "The Concept of Hoisting – How declarations are processed before execution and its effects on code behavior.",
                "Primitive Data Types in JavaScript – The basic building blocks: string, number, boolean, null, undefined, bigint, and symbol.",
                "Strings as Textual Data – Using strings for text, literals, and interpolation.",
                "Numbers as Numeric Data – Using number types for arithmetic and precision handling.",
                "Boolean Values for Logical Operations – The use of true and false for decision-making in programs.",
                "Undefined vs Null – Understanding the difference between missing and intentionally empty values.",
                "The typeof Operator – The primary way to inspect the data type of values in JavaScript.",
                "Objects as Collections of Properties – Non-primitive structures used to store key–value pairs.",
                "Arrays as Ordered Lists – Special objects designed for managing sequences of values.",
                "Iteration Over Arrays – Accessing elements sequentially using loops and iteration methods.",
                "JSON as a Data Exchange Format – The standard for exchanging structured data in JavaScript and beyond.",
                "Maps for Key–Value Storage – The Map collection for flexible key-based data storage.",
                "Sets for Unique Values – Using Set to maintain lists of non-duplicated values.",
                "Arithmetic Operators in JavaScript – Basic operators for performing mathematical calculations.",
                "Comparison Operators for Equality and Ordering – Tools for comparing values and expressions.",
                "Logical Operators for Boolean Expressions – Building complex conditions with AND, OR, and NOT.",
                "The Ternary Conditional Operator – A concise alternative to traditional conditionals.",
                "The if and else Statements – Branching logic to run code selectively.",
                "The switch Statement – Handling multiple possible conditions more clearly.",
                "The for Loop – A structured way to repeat code for a known number of iterations.",
                "The while Loop – Repetition controlled by a logical condition.",
                "The do...while Loop – Loop structure that always executes at least once.",
                "The for...in Loop – Iterating over enumerable object properties.",
                "The for...of Loop – Iterating over iterable data like arrays and strings.",
                "Loop Control with break and continue – Altering loop behavior by skipping or ending iterations.",
                "Exception Handling with Try–Catch – Structured error management in JavaScript programs.",
                "The throw Statement for Custom Errors – Creating and propagating new error conditions.",
                "Built-in Error Types – Standard JavaScript errors like TypeError, ReferenceError, and their meanings.",
                "Functions as Code Blocks – Encapsulating logic using function declarations and expressions.",
                "Function Arguments and Return Values – Passing input to functions and returning outputs.",
                "Default Parameters in Functions – Setting fallbacks for missing arguments.",
                "Arrow Functions – Concise syntax for defining functions with lexical this.",
                "Lexical Scope in JavaScript – Rules that determine variable visibility in nested code.",
                "Closures as Persistent Environments – Functions that remember the scope where they were defined.",
                "Recursive Functions – Functions that call themselves to solve problems step by step.",
                "The this Keyword in Methods – Context-sensitive behavior of this within object methods.",
                "Callbacks as Function Parameters – Passing functions as arguments for deferred execution.",
                "The Fetch API for Basic Requests – Performing asynchronous HTTP requests using promises.",
                "Modules and Reusability with Imports and Exports – Splitting programs into reusable files.",
                "Developer Tools in Browsers – Using consoles and debuggers to inspect and troubleshoot code.",
                "The Document Object Model (DOM) – The structured representation of web pages accessible from JavaScript.",
            ],
            "tech_allied": [
                "Developing debugging discipline using browser developer tools and console.",
                "Reading and interpreting JavaScript error stack traces effectively.",
                "Understanding official ECMAScript documentation for language features.",
                "Practicing code readability and commenting standards early.",
                "Recognizing common beginner pitfalls like global scope pollution and variable shadowing."
            ],
        },
        "medium": {
            "tech": [
                "Rest Parameters in Functions – Collecting multiple arguments into a single array.",
                "Immediately Invoked Function Expressions (IIFEs) – A pattern for executing functions instantly while isolating scope.",
                "Differences in this Between Arrow and Regular Functions – How function type changes binding behavior.",
                "Explicitly Controlling Function Context – Using call, apply, and bind to control execution context.",
                "The Event Loop and Concurrency Model – How JavaScript handles asynchronous tasks on a single thread.",
                "The Call Stack vs the Task Queue – Two key data structures for executing and scheduling operations.",
                "Microtasks and Macrotasks in Scheduling – Different priorities of asynchronous operations.",
                "Callback Hell – The readability problems of deeply nested callbacks.",
                "Chaining Promises for Sequential Operations – Cleaner structure for managing dependent async tasks.",
                "Error Handling in Promises – Using .catch and .finally to deal with failures.",
                "Async/Await Syntax – Writing asynchronous code in a synchronous style.",
                "Error Handling in Async Functions – Combining try...catch with async/await.",
                "Promise.all for Parallel Execution – Running multiple promises simultaneously and collecting results.",
                "Promise.race for Competing Operations – Returning the first settled promise among many.",
                "Using Fetch with Async/Await – Simplifying network requests with modern syntax.",
                "Parsing and Handling JSON from APIs – Extracting structured data from responses.",
                "XMLHttpRequest (XHR) Basics – The older callback-based approach to network requests.",
                "Cross-Origin Resource Sharing (CORS) – Browser security model for resource requests.",
                "CommonJS Modules in Node.js – Organizing code with require and module.exports.",
                "ECMAScript Modules (ESM) – Standardized imports and exports for modular JavaScript.",
                "Interoperability Between Module Systems – Challenges when mixing CJS and ESM code.",
                "Object Destructuring – Extracting properties directly into variables.",
                "Array Destructuring – Extracting array elements into variables.",
                "The Spread Operator – Expanding arrays or objects in new contexts.",
                "The Rest Operator – Grouping multiple elements into a single variable.",
                "Template Literals – Embedding expressions into string literals.",
                "Tagged Template Literals – Creating custom string-processing functions.",
                "The Symbol Type – Special primitive values for unique identifiers.",
                "WeakMap for Object-Keyed Storage – Key–value storage that avoids memory leaks.",
                "WeakSet for Unique Object Collections – Collections that hold weakly referenced objects.",
                "Shallow vs Deep Copies of Objects – Understanding object duplication at different levels.",
                "Value vs Reference in JavaScript – Distinguishing primitive assignment from object references.",
                "Prototypes and Prototype Chains – The foundation of JavaScript inheritance.",
                "Inheritance with Object.create – Directly linking objects for inheritance.",
                "Iterating Over Object Properties – Using Object.keys, Object.values, and Object.entries.",
                "Iterators and the Iterator Protocol – Interfaces for sequential data access.",
                "Asynchronous Iterators with for...await – Iterating over streams of async data.",
                "Event-Driven Programming in JavaScript – Designing programs around events and handlers.",
                "DOM Event Listeners – Attaching functions to respond to user interactions.",
                "Event Bubbling and Capturing – The two phases of DOM event propagation.",
                "Element Selection APIs – Methods like querySelector for finding elements.",
                "DOM Manipulation with JavaScript – Changing text, attributes, and styles.",
                "Handling User Input with Events – Responding to clicks, keyboard input, and other actions.",
                "LocalStorage API – Persistent key–value storage in browsers.",
                "SessionStorage API – Temporary storage tied to a session.",
                "JSON.stringify and JSON.parse – Converting objects to and from JSON strings.",
                "Debugging Asynchronous Code – Techniques for tracing promises and async calls.",
                "Common JavaScript Runtime Errors – Understanding common error categories.",
                "Strict Mode in JavaScript – Enabling safer parsing and error handling.",
                "Module Bundlers in Modern Development – Tools like Webpack for packaging code.",
            ],
            "tech_allied": [
                "Writing modular, maintainable code and organizing files logically.",
                "Understanding asynchronous behavior and avoiding common concurrency mistakes.",
                "Reading and evaluating third-party library documentation.",
                "Using version control (Git) for collaborative coding and history tracking.",
                "Debugging complex async flows with Promises, async/await, and the event loop.",
            ],
        },
        "hard": {
            "tech": [
                "Prototypal Inheritance in Depth – How JavaScript objects delegate property access along prototype chains.",
                "Prototype vs Class-Based Inheritance – Comparing JavaScript's native model with classical OOP.",
                "ES6 Class Syntax – Cleaner syntax for working with prototypes and inheritance.",
                "Constructors in Classes – Special methods for initializing object state.",
                "Instance Methods in Classes – Defining behaviors that belong to individual objects.",
                "Static Methods in Classes – Functions bound to the class rather than its instances.",
                "Class Inheritance with extends – Reusing and extending functionality through subclassing.",
                "The Role of super in Classes – Accessing parent constructors and methods.",
                "Private Fields in Classes – Encapsulation with fields hidden from outside code.",
                "Getters and Setters for Encapsulation – Customizing access to object properties.",
                "Custom Error Classes – Extending Error for application-specific exceptions.",
                "Garbage Collection in JavaScript – How unused memory is automatically reclaimed.",
                "The Memory Lifecycle – Allocation, usage, and release of memory resources.",
                "Identifying Memory Leaks – Common patterns that prevent memory from being freed.",
                "Weak References in Garbage Collection – Data structures that don't block memory cleanup.",
                "Profiling Memory and Performance – Tools for measuring and optimizing code behavior.",
                "The Browser Rendering Lifecycle – How browsers parse, paint, and update pages.",
                "Event Delegation – Efficiently handling events through propagation.",
                "The Shadow DOM – Encapsulating markup and styles for components.",
                "Web Components Overview – Building reusable custom elements.",
                "The Custom Elements API – Defining and registering new HTML elements.",
                "Dynamic Imports with import() – Loading modules on demand.",
                "Tree Shaking in Bundlers – Eliminating unused code from final builds.",
                "Polyfills and Transpilation – Ensuring compatibility with older environments.",
                "Feature Detection in JavaScript – Testing support before using modern features.",
                "Asynchronous Iterators in Real APIs – Handling streams of data like network responses.",
                "Implementing Promises from Scratch – Understanding how Promises work internally.",
                "Custom Iterators in JavaScript – Designing objects that follow the iterator protocol.",
                "Generator Functions and Lazy Evaluation – Yielding values on demand instead of eagerly.",
                "The Observer Pattern – Managing communication between objects with observers.",
                "Publish–Subscribe Pattern – Decoupling senders and receivers of messages.",
                "Function Debouncing – Limiting function execution to reduce unnecessary calls.",
                "Function Throttling – Controlling the rate of repeated executions.",
                "Currying Functions – Transforming functions into sequences of unary functions.",
                "Partial Application – Pre-filling some function arguments for later use.",
                "Function Composition – Combining smaller functions into pipelines.",
                "Immutability in JavaScript – Designing programs around data that never changes.",
                "Functional Programming in JavaScript – Applying functional techniques to everyday code.",
                "Reactive Programming Concepts – Modeling applications around changing data streams.",
                "The Proxy Object in JavaScript – Intercepting and customizing fundamental operations.",
                "The Reflect API – Standard methods for object manipulation at a meta level.",
                "Metaprogramming in JavaScript – Writing programs that manipulate other programs.",
                "Internationalization API (Intl) – Formatting dates, numbers, and currencies globally.",
                "Advanced Regular Expressions – Constructing complex patterns for text processing.",
                "Regex-Based Parsers and Validators – Using regex for structured input validation.",
                "Tail Call Optimization – Efficient recursion with no stack growth.",
                "Async Generators for Streaming Data – Combining async and generator patterns.",
                "Worker Threads in Node.js – Running CPU-bound tasks in parallel.",
                "Web Workers in the Browser – Offloading computations from the main thread.",
                "Specialization Beyond Core JavaScript – Transitioning into frontend frameworks or backend runtimes.",
            ],
            "tech_allied": [
                "Profiling performance and memory usage using browser and Node.js tools.",
                "Understanding architectural patterns like Observer, Pub/Sub, and functional composition.",
                "Evaluating ecosystem tools such as bundlers, transpilers, and polyfills for large projects.",
                "Writing code that balances performance, readability, and maintainability.",
                "Keeping up with evolving JavaScript standards, proposals, and emerging best practices.",
                ],
        },
    },
    "Node JS Developer": {
        "easy": {
            "tech": [
                "Installing Node.js – Setting up Node.js on different operating systems.",
                "Running a Node.js Script – Using node filename.js to execute scripts from the command line.",
                "Node REPL – Interactive console to test JavaScript expressions and functions.",
                "Node.js History – Understanding its creation, evolution, and adoption in server-side applications.",
                "Event Loop Basics – The mechanism that allows Node.js to handle asynchronous operations efficiently.",
                "Callbacks in Node.js – Functions passed as arguments to be executed later.",
                "Promises Overview – Objects representing future completion or failure of async operations.",
                "Async/Await Syntax – Modern, cleaner approach to writing asynchronous code.",
                "setTimeout and setInterval – Scheduling tasks for later execution.",
                "process.nextTick – Scheduling a callback to run immediately after the current operation.",
                "setImmediate – Queues a callback to run after I/O events in the next cycle.",
                "Node.js Core Modules – Built-in modules like fs, path, and http for server-side functionality.",
                "fs Module Basics – Reading, writing, and managing files.",
                "path Module Basics – Manipulating file and directory paths safely across platforms.",
                "Error Handling Fundamentals – Catching synchronous and asynchronous errors.",
                "try…catch in Async Code – Handling exceptions with async/await.",
                "Custom Error Objects – Creating user-defined errors for better debugging.",
                "CommonJS Modules – Organizing code with require() and module.exports.",
                "ESM Modules – Using import and export syntax in Node.js.",
                "package.json Overview – Project metadata, dependencies, and scripts.",
                "Installing Packages Locally – npm install <package> for project-specific dependencies.",
                "Installing Packages Globally – npm install -g <package> for system-wide tools.",
                "npm Scripts – Automating tasks like starting servers or running tests.",
                "Semantic Versioning – Understanding major, minor, and patch versions of packages.",
                "npm init – Creating a new Node.js project with configuration.",
                "npm update and uninstall – Managing package versions and removal.",
                "Console Module – Logging information, warnings, and errors for debugging.",
                "Global vs Local Scope – Understanding variable scoping in Node.js modules.",
                "__dirname and __filename – Accessing current file and directory paths.",
                "process Object – Accessing runtime info, environment variables, and command-line arguments.",
                "Buffer Basics – Working with binary data in Node.js.",
                "EventEmitter – Creating and handling custom events.",
                "Node.js Lifecycle – Understanding module caching and process execution flow.",
                "Understanding the Stack and Heap – Memory allocation basics for Node.js programs.",
                "Garbage Collection Basics – How Node.js automatically frees unused memory.",
                "Node.js REPL Commands – Useful shortcuts and inspection methods.",
                "Global Objects in Node.js – Accessing process, console, Buffer, and other globals.",
                "Node.js Execution Context – Differentiating between module and global context.",
                "require.resolve – Determining the path of a module.",
                "__non_webpack_require – Avoiding conflicts with bundlers.",
                "Importing JSON Files – Reading static JSON data as modules.",
                "Node.js Event Loop Phases – Understanding timers, I/O callbacks, and microtasks.",
                "nextTick vs setImmediate – Knowing their order in the event loop.",
                "Handling Multiple Async Operations – Using Promise.all and Promise.race.",
                "Asynchronous Error Patterns – Catching errors in callbacks vs promises.",
                "Reading Environment Variables – Using process.env for configuration.",
                "Node.js File Paths – Using path.join and path.resolve for platform-safe paths.",
                "Debugging Basic Node.js Scripts – Using console.log and basic inspector flags.",
            ],
            "tech_allied": [
                "REST fundamentals",
                "Simple logging",
                "dotenv and config handling",
                "Basic testing (Jest)",
                "Error handling basics",
                "HTTP status codes and content types",
                "Package management and semver",
                "Debugging (node --inspect)",
                "Basic containerization (Dockerfile)",
            ],
        },
        "medium": {
            "tech": [
                "HTTP Module Overview – Creating simple web servers using Node’s core module.",
                "Creating an Express Server – Simplifying HTTP handling with Express.js.",
                "Express Routing Basics – Mapping URLs to handler functions.",
                "Middleware in Express – Functions that intercept requests and responses.",
                "Error-Handling Middleware – Centralized error handling for Express apps.",
                "Fastify Overview – High-performance alternative to Express.js.",
                "NestJS Overview – Structured, TypeScript-first framework inspired by Angular.",
                "Serving Static Files – Exposing HTML, CSS, and JS files via Node.js servers.",
                "Handling GET Requests – Responding to HTTP GET methods.",
                "Handling POST Requests – Receiving and processing data sent from clients.",
                "Query Parameters – Reading values passed in URLs.",
                "Route Parameters – Capturing dynamic URL segments.",
                "Express Router – Modularizing routes for scalable applications.",
                "CORS Middleware – Allowing cross-origin requests safely.",
                "JSON Parsing Middleware – Parsing incoming JSON payloads automatically.",
                "Authentication with Passport.js – Adding login strategies to Node applications.",
                "JWT Authentication – Secure stateless authentication using tokens.",
                "Role-Based Authorization – Restricting access based on user roles.",
                "Connecting to PostgreSQL – Using ORMs or query builders for SQL databases.",
                "Sequelize ORM Overview – Managing relational data with JavaScript objects.",
                "Prisma ORM Overview – Modern, type-safe ORM for Node.js and TypeScript.",
                "Knex.js Query Builder – Writing SQL queries programmatically.",
                "Connecting to MongoDB – Using native driver or Mongoose ODM.",
                "Mongoose Schemas – Defining structured documents for MongoDB collections.",
                "CRUD Operations with Databases – Create, read, update, delete operations.",
                "Validating Data Before DB Operations – Using libraries or custom validators.",
                "Error Handling in APIs – Returning consistent error responses.",
                "Async/Await in API Routes – Simplifying asynchronous route handling.",
                "Unit Testing with Jest – Testing functions and modules individually.",
                "Integration Testing APIs – Testing API endpoints with real requests.",
                "E2E Testing with Playwright – Simulating real HTTP requests for full flows.",
                "Morgan HTTP Logger – Logging incoming requests in Express.",
                "Winston Logger – Flexible logging for console, files, and remote targets.",
                "Environment-Based Configuration – Loading different settings for dev, test, and prod.",
                "dotenv Overview – Managing environment variables from .env files.",
                "Handling File Uploads – Using multer or other middleware.",
                "Streaming File Uploads – Processing large files in chunks to save memory.",
                "Serving JSON Responses – Standardizing API output for client consumption.",
                "Using Template Engines – Rendering HTML from templates in server responses.",
                "Async Error Propagation – Using next(err) for centralized error handling.",
                "Body Parsing Middleware – Parsing URL-encoded or JSON payloads.",
                "Cookie Handling – Reading and writing HTTP cookies in Node.",
                "Session Management – Persisting user sessions using libraries like express-session.",
                "Compression Middleware – Reducing response size for faster delivery.",
                "Rate Limiting Middleware – Protecting APIs from abuse or DoS attacks.",
                "Helmet for Security – Setting HTTP headers for protection against vulnerabilities.",
                "API Versioning Strategies – Supporting multiple versions of an API concurrently.",
                "Pagination in APIs – Efficiently delivering large datasets in chunks.",
                "Query Filtering and Sorting – Allowing flexible API queries for client data needs.",
                "CORS Policies and Security – Balancing cross-origin access with security best practices.",
            ],
            "tech_allied": [
                "Databases (Mongo/Postgres) drivers",
                "Caching (Redis)",
                "Observability (logs/metrics/traces)",
                "Authentication/JWT",
                "Testing: integration/E2E",
                "API documentation (OpenAPI/Swagger)",
                "Background jobs and queues (BullMQ)",
                "Secrets management",
                "Container orchestration basics",
            ],
        },
        "hard": {
            "tech": [
                "Node.js Worker Threads – Running CPU-intensive tasks in separate threads.",
                "Cluster Module – Scaling Node applications across multiple CPU cores.",
                "child_process Module – Spawning external processes for heavy tasks.",
                "Streams Overview – Efficiently reading/writing large datasets in chunks.",
                "Readable Streams – Consuming data progressively.",
                "Writable Streams – Writing large data incrementally.",
                "Duplex Streams – Streams that can read and write simultaneously.",
                "Transform Streams – Modifying data as it passes through a stream.",
                "Backpressure Handling – Managing fast producers and slow consumers in streams.",
                "Buffer vs Stream – Memory-efficient data processing with streams.",
                "File Streaming Example – Reading/writing large files without blocking the event loop.",
                "Network Streams – Handling TCP or HTTP data streams.",
                "Debugging Node.js with --inspect – Connecting Chrome DevTools for live debugging.",
                "Heap Snapshots – Inspecting memory usage to find leaks.",
                "CPU Profiling – Measuring execution time of functions for performance optimization.",
                "Memory Leak Patterns – Common pitfalls causing excessive memory retention.",
                "Event Loop Monitoring – Detecting blocked operations affecting scalability.",
                "Cluster Load Balancing – Distributing incoming connections across multiple processes.",
                "Graceful Shutdowns – Handling SIGINT and SIGTERM signals for cleanup.",
                "pm2 Process Manager – Keeping Node apps alive in production, handling restarts.",
                "Logging Best Practices – Structured logs for production monitoring.",
                "Log Rotation – Managing disk usage and log retention.",
                "Monitoring Node Apps – Using tools like Prometheus, Grafana, or New Relic.",
                "Profiling HTTP Servers – Measuring request latency and throughput.",
                "Cache Strategies – Reducing database load with in-memory caching like Redis.",
                "Rate Limiting in Production – Preventing abuse of APIs at scale.",
                "Security Best Practices – Input validation, sanitization, and headers.",
                "HTTPS and TLS Setup – Securing APIs with encryption.",
                "Handling Large Payloads – Efficiently processing big requests and responses.",
                "Streaming API Responses – Sending data incrementally to reduce memory footprint.",
                "Compression and Gzip – Reducing response size for faster network delivery.",
                "API Gateway Basics – Managing multiple microservices behind a single endpoint.",
                "Reverse Proxy with Nginx – Fronting Node apps for security and load balancing.",
                "Dockerizing Node.js Apps – Packaging apps for reproducible deployments.",
                "Continuous Integration (CI) – Running automated builds and tests.",
                "Continuous Deployment (CD) – Automating app deployment pipelines.",
                "Health Checks – Ensuring services are alive and responsive.",
                "Graceful Error Responses – Returning meaningful errors to clients.",
                "Async Performance Patterns – Avoiding blocking operations.",
                "Clustered Caching – Sharing caches across Node processes.",
                "WebSocket Servers – Real-time bidirectional communication with clients.",
                "Socket.IO Basics – Abstracting WebSocket communication.",
                "Handling High Concurrency – Techniques for thousands of simultaneous connections.",
                "Scaling APIs Horizontally – Multiple servers behind a load balancer.",
                "Scaling Databases – Sharding, replication, and connection pooling.",
                "Microservices with Node.js – Designing modular, independent services.",
                "Serverless Node.js – Deploying functions on AWS Lambda, Vercel, or Netlify.",
                "Performance Benchmarking – Using tools like autocannon or wrk.",
                "Profiling Memory Leaks in Production – Detecting leaks in live environments.",
                "Node.js Production Checklist – Best practices covering security, performance, and maintainability.",
            ],
            "tech_allied": [
                "Horizontal scaling",
                "Zero-downtime deploys",
                "Message queues (Kafka/RabbitMQ)",
                "Distributed tracing",
                "Advanced security (OWASP ASVS)",
                "Circuit breakers and rate limits at edge",
                "API gateways and service meshes",
                "Chaos engineering and resilience testing",
                "Cost/perf trade-offs and SLOs",
            ],
        },
    },
    "Express JS Developer": {
        "easy": {
            "tech": [
                "Installing Express – Using npm to add Express to a Node.js project.",
                "Creating an Express App – Instantiating an Express application object.",
                "Starting the Server – Using app.listen() to accept incoming HTTP requests.",
                "Understanding Ports – Configuring and binding servers to a specific network port.",
                "Request-Response Cycle – How Express handles an incoming request and generates a response.",
                "app.get() Method – Handling GET requests for specific routes.",
                "app.post() Method – Handling POST requests for data submission.",
                "app.put() Method – Handling PUT requests to update resources.",
                "app.delete() Method – Handling DELETE requests to remove resources.",
                "req Object Basics – Accessing query parameters, route parameters, headers, and body.",
                "res Object Basics – Sending responses using res.send(), res.json(), and res.status().",
                "res.render() – Sending server-rendered HTML using a template engine.",
                "Middleware Concept – Functions that process requests before they reach route handlers.",
                "app.use() Method – Applying middleware globally to all routes.",
                "Route-Specific Middleware – Applying middleware only to certain routes.",
                "Custom Middleware – Writing functions for logging, request modifications, or authentication.",
                "Ordering Middleware – Understanding that middleware executes in the order defined.",
                "Built-in Middleware – Using Express utilities like express.json() and express.urlencoded().",
                "Third-Party Middleware – Using packages like cors, helmet, or morgan.",
                "Error-Handling Middleware – Centralizing error handling with a function accepting (err, req, res, next).",
                "Next Function in Middleware – Passing control to the next middleware in the chain.",
                "Routing Parameters – Capturing dynamic segments in route paths.",
                "Query Parameters – Accessing optional data passed in the URL.",
                "Request Body Parsing – Handling JSON and form data in POST/PUT requests.",
                "Serving Static Files – Exposing images, CSS, and JS via express.static().",
                "HTTP Status Codes – Using codes to indicate request results (200, 404, 500, etc.).",
                "REST Principles Overview – Designing APIs using resources, HTTP verbs, and stateless operations.",
                "Plural Resource Naming – Using conventions like /users and /products.",
                "CRUD Operations – Implementing Create, Read, Update, Delete endpoints.",
                "Environment Variables in Express – Using .env files to configure apps.",
                "Logging Requests – Using console or middleware to monitor incoming traffic.",
                "Debugging Express Apps – Techniques using node --inspect or logging.",
                "Testing Express Routes – Using Jest or Supertest to verify endpoints.",
                "Hello World Route – Simple route to verify server setup.",
                "404 Handler – Catching unmatched routes for user-friendly errors.",
                "CORS Basics – Allowing cross-origin requests safely.",
                "JSON Responses – Sending structured API data with res.json().",
                "Route Organization – Keeping related routes in separate files.",
                "MVC Pattern Overview – Separating models, views, and controllers.",
                "Controllers in Express – Functions handling route logic.",
                "Service Layer Concept – Encapsulating business logic outside controllers.",
                "Express Router – Modular route management with express.Router().",
                "Middleware Chaining – Using multiple middleware functions in sequence.",
                "Mounting Routers – Attaching routers to specific base paths.",
                "Route Prefixing – Structuring route URLs for maintainability.",
                "Parameter Validation – Ensuring route or query parameters meet expectations.",
                "Using Async in Middleware – Handling asynchronous operations safely.",
                "Promise Rejection Handling – Catching errors in async middleware to prevent crashes.",
                "Server Shutdown Handling – Graceful termination of Express apps on signals.",
            ],
            "tech_allied": [
                "RESTful design",
                "Validation (Joi/Zod)",
                "CORS",
                "Sessions/cookies",
                "Basic security headers",
                "OpenAPI basics for Express",
                "Error logging and correlation IDs",
                "Simple rate limiting",
                "Basic pagination patterns",
            ],
        },
        "medium": {
            "tech": [
                "REST API Design Principles – Structuring endpoints, verbs, and responses.",
                "GET Endpoint Best Practices – Retrieving data efficiently.",
                "POST Endpoint Best Practices – Creating new resources securely.",
                "PUT and PATCH Endpoints – Updating resources partially or fully.",
                "DELETE Endpoint Best Practices – Removing resources safely.",
                "Status Codes for REST – 200, 201, 400, 401, 403, 404, 500.",
                "Sending Consistent JSON Responses – Structuring API output uniformly.",
                "JWT Authentication Basics – Using tokens to verify user identity.",
                "Session-Based Authentication – Using cookies to track logged-in users.",
                "Role-Based Access Control – Restricting routes by user permissions.",
                "Custom Authentication Middleware – Protecting routes with middleware functions.",
                "Password Hashing – Storing passwords securely using bcrypt or similar libraries.",
                "Input Validation Middleware – Preventing invalid or malicious data.",
                "Sanitization of Input – Cleaning user-provided data to prevent XSS or injection attacks.",
                "Express-Validator – Library for validating and sanitizing inputs.",
                "Centralized Error Handler – Handling errors consistently across all routes.",
                "Error Logging – Recording error details for debugging and monitoring.",
                "Throwing Custom Errors – Creating structured error objects with codes and messages.",
                "Handling Async Errors in Routes – Avoiding unhandled promise rejections.",
                "Rate Limiting Middleware – Protecting APIs from abuse using express-rate-limit.",
                "Helmet Security Middleware – Setting HTTP headers for protection.",
                "CSRF Protection – Guarding against cross-site request forgery attacks.",
                "CORS Policies – Configuring cross-origin access securely.",
                "API Versioning – Supporting multiple API versions simultaneously.",
                "Pagination in API Responses – Sending large datasets in chunks.",
                "Filtering and Sorting API Data – Allowing flexible queries in GET requests.",
                "Conditional GET Requests – Using ETag or Last-Modified headers.",
                "Caching Strategies – Reducing repeated computation with in-memory or Redis cache.",
                "Logging Middleware with Morgan – Structured HTTP request logging.",
                "Request Timing – Measuring duration of API calls for performance.",
                "Using Query Parameters – Filtering and customizing API responses.",
                "Handling File Uploads – Using multer to accept files via multipart/form-data.",
                "Streaming File Uploads – Efficiently processing large uploads.",
                "Sending Files to Clients – Using res.sendFile() or streaming large files.",
                "Templating Engines Setup – Configuring EJS, Pug, or Handlebars for SSR.",
                "Rendering Dynamic Pages – Sending server-rendered HTML to users.",
                "Passing Data to Templates – Injecting data into templates via res.render().",
                "Partial Templates – Reusing components like headers and footers.",
                "Layout Templates – Using master layouts for consistent structure.",
                "Integrating Database in Routes – Using Mongoose or Sequelize in controllers.",
                "Performing CRUD with Database – Mapping API requests to database operations.",
                "Error Handling in DB Operations – Catching validation and connection errors.",
                "Using Async/Await with DB Calls – Cleaner handling of asynchronous operations.",
                "Transactions in SQL Databases – Ensuring atomicity of operations.",
                "Population in MongoDB – Retrieving related documents automatically.",
                "Indexing for Performance – Improving query speed in databases.",
                "Environment-Specific DB Config – Different connections for dev, test, prod.",
                "Connection Pooling – Efficiently managing database connections.",
                "Database Migrations – Updating schema safely over time.",
                "API Documentation – Using Swagger or Postman to describe endpoints.",
            ],
            "tech_allied": [
                "ORM/ODM (Prisma/Sequelize/Mongoose)",
                "API versioning",
                "OpenAPI/Swagger",
                "Monitoring/alerts",
                "CI/CD basics",
                "Migrations and schema drift",
                "Background processing (bull/agenda)",
                "SaaS integrations (Stripe/SendGrid)",
                "Observability (OpenTelemetry for Node)",
            ],
        },
        "hard": {
            "tech": [
                "Clustering Express Servers – Running multiple Node processes for concurrency.",
                "Load Balancing Express Apps – Distributing requests across instances.",
                "Graceful Shutdowns – Cleaning up resources before process exit.",
                "Streaming Responses – Sending large data in chunks.",
                "Streaming Requests – Handling large uploads efficiently.",
                "Compression Middleware – Reducing payload sizes with Gzip.",
                "Reverse Proxy with Nginx – Fronting Express servers for performance and security.",
                "Caching Responses – Using Redis or in-memory caches to improve performance.",
                "Health Checks – Monitoring API uptime and readiness.",
                "Monitoring Middleware – Collecting metrics like request duration and errors.",
                "Integrating Prometheus – Exporting metrics for observability.",
                "Using Grafana Dashboards – Visualizing API performance and logs.",
                "Profiling Node.js Performance – Detecting slow routes and memory issues.",
                "Memory Leak Detection – Monitoring and preventing excessive memory usage.",
                "CPU Profiling – Identifying high CPU usage routes.",
                "Using PM2 for Process Management – Keeping apps alive and managing clusters.",
                "Logging in Production – Structuring logs for long-term analysis.",
                "Log Rotation – Managing disk usage for log files.",
                "Using Docker with Express – Containerizing apps for reproducible deployments.",
                "CI/CD Pipelines – Automating build, test, and deploy processes.",
                "Error Reporting Services – Integrating Sentry or similar tools.",
                "Graceful Error Responses – Returning user-friendly error messages.",
                "Rate Limiting in Production – Throttling API requests to prevent abuse.",
                "WebSocket Integration – Adding real-time capabilities to Express apps.",
                "Socket.IO Setup – Simplifying WebSocket communications.",
                "Event-Driven Architecture – Using events to decouple logic.",
                "Microservices with Express – Building small, independent services.",
                "Service Discovery – Allowing microservices to locate each other dynamically.",
                "API Gateway Integration – Routing requests to multiple services.",
                "Reverse Proxy Caching – Speeding up responses with Nginx caching.",
                "JWT Expiration Handling – Refreshing or invalidating expired tokens.",
                "OAuth Integration – Third-party authentication (Google, Facebook, etc.).",
                "Content Security Policy – Mitigating XSS and injection attacks.",
                "Helmet Advanced Settings – Adding extra HTTP headers for security.",
                "Rate-Limiting Advanced – Using Redis to scale rate limiting.",
                "Session Store Scaling – Using Redis or DB-backed stores for sessions.",
                "HTTPS/TLS in Production – Securing connections with certificates.",
                "Environment Configuration Management – Handling secrets securely.",
                "Container Orchestration – Running Express apps with Kubernetes.",
                "Scaling Databases with Express – Sharding, replication, connection pooling.",
                "Monitoring WebSockets – Ensuring real-time connections are healthy.",
                "Load Testing APIs – Using tools like autocannon or k6.",
                "Stress Testing – Determining maximum capacity and bottlenecks.",
                "Graceful Degradation – Handling failures without crashing the app.",
                "Feature Flags – Enabling/disabling features without redeploying.",
                "Rate-Limited Endpoints – Fine-grained protection for critical routes.",
                "Using CDN with Express – Offloading static assets for speed.",
                "Debugging in Production – Analyzing logs and live issues safely.",
                "Error Recovery Patterns – Retry strategies and fallback mechanisms.",
                "Express Production Checklist – Security, performance, logging, and monitoring best practices.",
            ],
            "tech_allied": [
                "Microservices gateways",
                "Service meshes",
                "Feature flags and rollouts",
                "Distributed cache",
                "Chaos testing",
                "Multi-region deployments and latency",
                "Advanced auth (OAuth device/code flows)",
                "Schema evolution and backward compatibility",
                "Blue/green vs canary deployments",
            ],
        },
    },
    "MERN Stack Developer": {
        "easy": {
            "tech": [
                "What is MERN Stack – Full-stack development using MongoDB, Express, React, and Node.js.",
                "Advantages of MERN – Single language (JavaScript) across the stack, code reuse, streamlined team collaboration.",
                "Prerequisite: JavaScript Mastery – Strong knowledge of ES6+, async/await, and functional programming.",
                "Prerequisite: HTML & CSS – Core web fundamentals for building frontends.",
                "Prerequisite: Git Basics – Version control for full-stack projects.",
                "Node.js Overview – Understanding the backend runtime environment.",
                "Express.js Overview – Minimalist backend framework for building APIs.",
                "React Overview – Library for building interactive frontend UIs.",
                "MongoDB Overview – Document-based NoSQL database using BSON/JSON.",
                "Setting Up Node.js Project – Creating package.json and installing dependencies.",
                "Setting Up React Project – Using Create React App or Vite.",
                "Setting Up MongoDB – Installing locally or using MongoDB Atlas.",
                "npm and Node Package Management – Installing local/global packages.",
                "Hello World Express Server – Creating a simple server responding to requests.",
                "Basic React Component – Creating functional components.",
                "JSX Syntax – Embedding HTML-like markup in JavaScript.",
                "React Props – Passing data from parent to child components.",
                "React State – Managing component-specific, mutable data.",
                "React Event Handling – Handling clicks, form submissions, and other events.",
                "req and res Objects in Express – Understanding request and response objects.",
                "CRUD Basics in MongoDB – insertOne, findOne, updateOne, deleteOne.",
                "Routing in Express – Handling GET, POST, PUT, DELETE requests.",
                "Middleware Concept – Functions that intercept requests for processing.",
                "Using express.json() – Parsing JSON request bodies.",
                "Serving Static Files in Express – Delivering HTML, CSS, JS files.",
                "Connecting React to APIs – Using Fetch or Axios to send HTTP requests.",
                "Connecting Express to MongoDB – Using Mongoose to handle database operations.",
                "Document Data Model – Flexible schema structure in MongoDB.",
                "BSON vs JSON – Differences and advantages in MongoDB.",
                "MongoDB Collections & Documents – Core database structure.",
                "React useEffect Hook – Handling side effects like API calls.",
                "React useState Hook – Managing local component state.",
                "React Forms – Handling user input with controlled components.",
                "Handling Form Submission – Sending data from React to Express backend.",
                "React Conditional Rendering – Displaying UI based on state or props.",
                "React Lists & Keys – Rendering dynamic lists efficiently.",
                "Express app.listen() – Starting server and listening on a port.",
                "Route Parameters in Express – Capturing dynamic values in routes.",
                "Query Parameters in Express – Accessing optional request data.",
                "React Component Reusability – Creating modular, reusable UI components.",
                "React Functional vs Class Components – Modern preference for functional components.",
                "React useRef Hook – Accessing DOM elements directly.",
                "React useContext Hook – Sharing state across components.",
                "React Router Basics – Navigating between pages in SPA.",
                "Mongoose Models – Defining schemas and creating models.",
                "Mongoose Validation – Ensuring data integrity before saving.",
                "Mongoose Queries – find(), findOne(), update(), delete().",
                "Node.js Async/Await – Handling asynchronous operations in backend.",
                "Basic Error Handling in Express – Using try/catch and middleware.",
                "End-to-End Flow Example – React frontend → Express API → MongoDB → back to React.",
            ],
            "tech_allied": [
                "Data modeling basics",
                "State management intro",
                "Env/config management",
                "Unit testing",
                "Auth basics",
                "Docker Compose for local dev",
                "Simple logging across services",
                "Static asset hosting (CDN) basics",
                "Local debugging of full stack",
            ],
        },
        "medium": {
            "tech": [
                "RESTful API Design – Structuring endpoints using HTTP verbs correctly.",
                "Express Router – Modularizing routes for maintainable code.",
                "Controllers in Express – Separating route logic into functions.",
                "Service Layer Concept – Encapsulating business logic outside controllers.",
                "Custom Middleware – Logging, authentication, or modifying requests.",
                "JWT Authentication – Securing APIs with JSON Web Tokens.",
                "Session-Based Authentication – Using cookies for logged-in users.",
                "Role-Based Authorization – Restricting routes by user roles.",
                "Input Validation – Sanitizing and validating requests in Express.",
                "Express-Validator Library – Simplifying validation and sanitization.",
                "Centralized Error Handling – Consistent error responses across the API.",
                "Pagination in API Responses – Handling large datasets efficiently.",
                "Filtering & Sorting Data – Implementing query-based filtering.",
                "Environment Variables – Using .env for configuration.",
                "Connecting React Forms to APIs – Submitting user data to Express endpoints.",
                "Axios Setup in React – Configuring API requests and interceptors.",
                "React useReducer Hook – Complex state management in UI.",
                "React useCallback/useMemo – Optimizing component performance.",
                "React Context API – Sharing global state across the app.",
                "React Query Basics – Fetching, caching, and synchronizing server data.",
                "Handling Async API Calls – Using async/await in frontend and backend.",
                "MongoDB Query Operators – $eq, $gt, $in, $and, $or, etc.",
                "MongoDB Projection – Returning only required fields.",
                "MongoDB Indexes – Optimizing queries with single and compound indexes.",
                "Aggregation Framework Basics – $match, $group, $sort, $project.",
                "React Component Lifecycle – Understanding mounting, updating, and unmounting.",
                "React useEffect Cleanup – Avoiding memory leaks in side effects.",
                "Handling Errors in React – Displaying messages and fallback UIs.",
                "CRUD in React + Express + MongoDB – Full-stack data operations.",
                "Template Engines in Express – Using EJS/Pug for server-side rendering.",
                "Serving React Build in Express – Hosting frontend in production backend.",
                "Connecting MongoDB Atlas – Cloud-hosted database for production.",
                "Data Validation in Mongoose – Schema-level validation rules.",
                "Mongoose Pre/Post Hooks – Running code before/after save or update.",
                "Environment-Specific Config – Handling dev, test, and production setups.",
                "Logging Middleware – Using Morgan or Winston for request logging.",
                "React Router Nested Routes – Structuring complex UI paths.",
                "State Lifting in React – Sharing state between components efficiently.",
                "Handling File Uploads in Express – Using Multer for multipart/form-data.",
                "Streaming Files in Express – Efficiently reading/writing large files.",
                "React Conditional Fetching – Load data based on state or route.",
                "Unit Testing Express Controllers – Using Jest or Vitest.",
                "Testing React Components – Using React Testing Library.",
                "Integration Testing MERN App – Testing full-stack flow with supertest.",
                "Error Recovery Patterns – Retry strategies for failed API calls.",
                "Handling Timezones and Dates – Using Date objects or libraries like Day.js.",
                "Basic Security Practices – HTTPS, helmet, input sanitization.",
                "CORS Configuration – Allowing frontend to communicate safely with backend.",
                "API Documentation – Using Swagger or Postman collections.",
                "End-to-End Example App – A small MERN CRUD project demonstrating full flow.",
            ],
            "tech_allied": [
                "DevOps (Docker Compose)",
                "Monitoring/logging stack",
                "E2E testing",
                "Scaling database reads/writes",
                "Security and secrets",
                "CI/CD for multi-service apps",
                "Feature flags and configuration",
                "Performance tracing across tiers",
                "Cost awareness (queries, bandwidth)",
            ],
        },
        "hard": {
            "tech": [
                "Clustering Node.js Servers – Scaling apps across CPU cores.",
                "Load Balancing MERN App – Distributing traffic across multiple instances.",
                "Dockerizing MERN App – Containerizing frontend, backend, and database.",
                "Kubernetes Basics – Deploying MERN apps in a cluster.",
                "React Performance Optimization – Memoization, code splitting, lazy loading.",
                "React Suspense & Lazy – Handling async component loading.",
                "SSR with React – Server-side rendering for SEO and performance.",
                "React Portals – Rendering UI outside the DOM hierarchy.",
                "React Error Boundaries – Catching runtime errors in components.",
                "Advanced MongoDB Indexing – Text, geospatial, and compound indexes.",
                "Sharding MongoDB – Horizontal scaling for massive datasets.",
                "Replica Sets – Ensuring high availability in MongoDB.",
                "Caching with Redis – Reducing load on database and backend.",
                "WebSockets in MERN – Real-time data updates.",
                "Socket.IO Integration – Simplifying bi-directional communication.",
                "Advanced JWT Handling – Refresh tokens, expiration, and revocation.",
                "OAuth Integration – Login with Google, Facebook, etc.",
                "Rate Limiting – Protecting APIs from abuse.",
                "Content Security Policy – Preventing XSS attacks.",
                "Advanced Helmet Config – Securing HTTP headers.",
                "Environment-Specific Secrets – Using Vault or dotenv safely.",
                "Performance Profiling – Detecting memory leaks and slow routes.",
                "Monitoring MERN App – Using Prometheus/Grafana or other observability tools.",
                "Health Checks & Readiness – For production deployment.",
                "Logging in Production – Structured logs with Winston or Bunyan.",
                "Error Reporting Tools – Integrating Sentry or LogRocket.",
                "End-to-End CI/CD Pipeline – Automatic build, test, and deploy.",
                "React Query Advanced Usage – Caching, pagination, and invalidation.",
                "GraphQL Alternative – Using Apollo Server/Client with MERN.",
                "Unit Testing MongoDB Models – Testing schema validations and hooks.",
                "Stress Testing APIs – Using tools like k6 or autocannon.",
                "Horizontal Scaling Backend – Clustering, worker threads, and load balancers.",
                "Vertical Scaling Considerations – Memory and CPU optimization.",
                "CDN Integration – Serving React assets via CDN.",
                "HTTPS & TLS – Securing frontend-backend communication.",
                "Caching Strategies in React – Memoization, SWR, or React Query.",
                "Service Layer Advanced Patterns – Repository and factory patterns.",
                "Microservices Architecture – Splitting backend into multiple Express services.",
                "API Gateway Basics – Centralized routing and authentication.",
                "Event-Driven MERN Apps – Using Node EventEmitter or message queues.",
                "GraphQL with MongoDB – Efficient querying alternative to REST.",
                "Session Store Scaling – Using Redis or DB-backed sessions.",
                "React Performance Profiling – Identifying unnecessary re-renders.",
                "Lazy Loading Images and Components – Optimizing frontend load time.",
                "SSR Caching Strategies – Reducing server-side rendering overhead.",
                "Multi-Tenancy in MERN Apps – Serving multiple clients from a single backend.",
                "Audit Logging – Tracking user actions for security and compliance.",
                "Blue/Green Deployment – Minimizing downtime during releases.",
                "Feature Flags – Enabling/disabling features without redeploying.",
                "MERN Production Checklist – Security, performance, monitoring, and scalability best practices.",
            ],
            "tech_allied": [
                "K8s deployments",
                "CDNs and edge caching",
                "Data migrations at scale",
                "Performance SLOs",
                "Cost optimization",
                "Observability end-to-end with traces",
                "Infrastructure as Code at scale",
                "Disaster recovery and backups",
                "Multi-region active/passive setups",
            ],
        },
    },
}
